"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importStar(require("axios"));
const assert_1 = require("assert");
const sinon_1 = require("sinon");
const botbuilder_1 = require("botbuilder");
const OpenAIModerator_1 = require("./OpenAIModerator");
const TurnState_1 = require("./TurnState");
const AI_1 = require("./AI");
const OpenAIPlanner_1 = require("./OpenAIPlanner");
const DefaultPromptManager_1 = require("./DefaultPromptManager");
describe('OpenAIModerator', () => {
    afterEach(() => {
        (0, sinon_1.restore)();
    });
    describe('reviewPrompt', () => {
        const adapter = new botbuilder_1.CloudAdapter();
        const planner = new OpenAIPlanner_1.OpenAIPlanner({
            apiKey: 'test',
            defaultModel: 'gpt-3.5-turbo'
        });
        const promptManager = new DefaultPromptManager_1.DefaultPromptManager({
            promptsFolder: ''
        });
        const historyOptions = {
            assistantHistoryType: 'text',
            assistantPrefix: 'Assistant:',
            lineSeparator: '\n',
            maxTokens: 1000,
            maxTurns: 3,
            trackHistory: true,
            userPrefix: 'User:'
        };
        const state = {
            conversation: new TurnState_1.TurnStateEntry({}),
            user: new TurnState_1.TurnStateEntry({}),
            temp: new TurnState_1.TurnStateEntry({
                history: '',
                input: '',
                output: ''
            })
        };
        const promptTemplate = {
            text: '',
            config: {
                type: 'completion',
                schema: 1,
                description: '',
                completion: {
                    frequency_penalty: 0,
                    max_tokens: 0,
                    presence_penalty: 0,
                    temperature: 0,
                    top_p: 0
                }
            }
        };
        it('should return plan with action `HttpErrorActionName` when `code` >= 400', async () => {
            (0, sinon_1.stub)(axios_1.default, 'create').returns({
                post() {
                    throw new axios_1.AxiosError('bad request', '400');
                }
            });
            const moderator = new OpenAIModerator_1.OpenAIModerator({
                apiKey: 'test',
                moderate: 'both'
            });
            const plan = await moderator.reviewPrompt(new botbuilder_1.TurnContext(adapter, { text: 'test' }), state, promptTemplate, {
                history: historyOptions,
                moderator: moderator,
                planner: planner,
                promptManager: promptManager
            });
            assert_1.strict.deepEqual(plan, {
                type: 'plan',
                commands: [
                    {
                        type: 'DO',
                        action: AI_1.AI.HttpErrorActionName,
                        entities: {
                            code: '400',
                            message: 'bad request'
                        }
                    }
                ]
            });
        });
        it('should throw when non-Axios error', async () => {
            (0, sinon_1.stub)(axios_1.default, 'create').returns({
                post() {
                    throw new Error('something went wrong');
                }
            });
            const moderator = new OpenAIModerator_1.OpenAIModerator({
                apiKey: 'test',
                moderate: 'both'
            });
            const res = moderator.reviewPrompt(new botbuilder_1.TurnContext(adapter, { text: 'test' }), state, promptTemplate, {
                history: historyOptions,
                moderator: moderator,
                planner: planner,
                promptManager: promptManager
            });
            await assert_1.strict.rejects(res);
        });
        it('should return plan with action `FlaggedInputActionName` when input is flagged', async () => {
            const result = {
                flagged: true,
                categories: {
                    hate: true,
                    'hate/threatening': true,
                    'self-harm': true,
                    sexual: true,
                    'sexual/minors': true,
                    violence: true,
                    'violence/graphic': true
                },
                category_scores: {
                    hate: 0,
                    'hate/threatening': 0,
                    'self-harm': 0,
                    sexual: 0,
                    'sexual/minors': 0,
                    violence: 0,
                    'violence/graphic': 0
                }
            };
            (0, sinon_1.stub)(axios_1.default, 'create').returns({
                post() {
                    return {
                        headers: {},
                        status: 200,
                        statusText: 'ok',
                        data: {
                            id: '1',
                            model: 'gpt-3.5-turbo',
                            results: [result]
                        }
                    };
                }
            });
            const moderator = new OpenAIModerator_1.OpenAIModerator({
                apiKey: 'test',
                moderate: 'both'
            });
            const plan = await moderator.reviewPrompt(new botbuilder_1.TurnContext(adapter, { text: 'test' }), state, promptTemplate, {
                history: historyOptions,
                moderator: moderator,
                planner: planner,
                promptManager: promptManager
            });
            assert_1.strict.deepEqual(plan, {
                type: 'plan',
                commands: [
                    {
                        type: 'DO',
                        action: AI_1.AI.FlaggedInputActionName,
                        entities: result
                    }
                ]
            });
        });
        it('should return `undefined` when input is not flagged', async () => {
            const result = {
                flagged: false,
                categories: {
                    hate: false,
                    'hate/threatening': false,
                    'self-harm': false,
                    sexual: false,
                    'sexual/minors': false,
                    violence: false,
                    'violence/graphic': false
                },
                category_scores: {
                    hate: 0,
                    'hate/threatening': 0,
                    'self-harm': 0,
                    sexual: 0,
                    'sexual/minors': 0,
                    violence: 0,
                    'violence/graphic': 0
                }
            };
            (0, sinon_1.stub)(axios_1.default, 'create').returns({
                post() {
                    return {
                        headers: {},
                        status: 200,
                        statusText: 'ok',
                        data: {
                            id: '1',
                            model: 'gpt-3.5-turbo',
                            results: [result]
                        }
                    };
                }
            });
            const moderator = new OpenAIModerator_1.OpenAIModerator({
                apiKey: 'test',
                moderate: 'both'
            });
            const plan = await moderator.reviewPrompt(new botbuilder_1.TurnContext(adapter, { text: 'test' }), state, promptTemplate, {
                history: historyOptions,
                moderator: moderator,
                planner: planner,
                promptManager: promptManager
            });
            assert_1.strict.equal(plan, undefined);
        });
    });
    describe('reviewPlan', () => {
        const adapter = new botbuilder_1.CloudAdapter();
        const state = {
            conversation: new TurnState_1.TurnStateEntry({}),
            user: new TurnState_1.TurnStateEntry({}),
            temp: new TurnState_1.TurnStateEntry({
                history: '',
                input: '',
                output: ''
            })
        };
        it('should return plan with action `HttpErrorActionName` when `code` >= 400', async () => {
            (0, sinon_1.stub)(axios_1.default, 'create').returns({
                post() {
                    throw new axios_1.AxiosError('bad request', '400');
                }
            });
            const moderator = new OpenAIModerator_1.OpenAIModerator({
                apiKey: 'test',
                moderate: 'both'
            });
            const plan = await moderator.reviewPlan(new botbuilder_1.TurnContext(adapter, { text: 'test' }), state, {
                type: 'plan',
                commands: [
                    {
                        type: 'SAY',
                        response: 'test'
                    }
                ]
            });
            assert_1.strict.deepEqual(plan, {
                type: 'plan',
                commands: [
                    {
                        type: 'DO',
                        action: AI_1.AI.HttpErrorActionName,
                        entities: {
                            code: '400',
                            message: 'bad request'
                        }
                    }
                ]
            });
        });
        it('should throw when non-Axios error', async () => {
            (0, sinon_1.stub)(axios_1.default, 'create').returns({
                post() {
                    throw new Error('something went wrong');
                }
            });
            const moderator = new OpenAIModerator_1.OpenAIModerator({
                apiKey: 'test',
                moderate: 'both'
            });
            const res = moderator.reviewPlan(new botbuilder_1.TurnContext(adapter, { text: 'test' }), state, {
                type: 'plan',
                commands: [
                    {
                        type: 'SAY',
                        response: 'test'
                    }
                ]
            });
            await assert_1.strict.rejects(res);
        });
        it('should return plan with action `FlaggedOutputActionName` when input is flagged', async () => {
            const result = {
                flagged: true,
                categories: {
                    hate: true,
                    'hate/threatening': true,
                    'self-harm': true,
                    sexual: true,
                    'sexual/minors': true,
                    violence: true,
                    'violence/graphic': true
                },
                category_scores: {
                    hate: 0,
                    'hate/threatening': 0,
                    'self-harm': 0,
                    sexual: 0,
                    'sexual/minors': 0,
                    violence: 0,
                    'violence/graphic': 0
                }
            };
            (0, sinon_1.stub)(axios_1.default, 'create').returns({
                post() {
                    return {
                        headers: {},
                        status: 200,
                        statusText: 'ok',
                        data: {
                            id: '1',
                            model: 'gpt-3.5-turbo',
                            results: [result]
                        }
                    };
                }
            });
            const moderator = new OpenAIModerator_1.OpenAIModerator({
                apiKey: 'test',
                moderate: 'both'
            });
            const plan = await moderator.reviewPlan(new botbuilder_1.TurnContext(adapter, { text: 'test' }), state, {
                type: 'plan',
                commands: [
                    {
                        type: 'SAY',
                        response: 'test'
                    }
                ]
            });
            assert_1.strict.deepEqual(plan, {
                type: 'plan',
                commands: [
                    {
                        type: 'DO',
                        action: AI_1.AI.FlaggedOutputActionName,
                        entities: result
                    }
                ]
            });
        });
        it('should return `undefined` when input is not flagged', async () => {
            const result = {
                flagged: false,
                categories: {
                    hate: false,
                    'hate/threatening': false,
                    'self-harm': false,
                    sexual: false,
                    'sexual/minors': false,
                    violence: false,
                    'violence/graphic': false
                },
                category_scores: {
                    hate: 0,
                    'hate/threatening': 0,
                    'self-harm': 0,
                    sexual: 0,
                    'sexual/minors': 0,
                    violence: 0,
                    'violence/graphic': 0
                }
            };
            (0, sinon_1.stub)(axios_1.default, 'create').returns({
                post() {
                    return {
                        headers: {},
                        status: 200,
                        statusText: 'ok',
                        data: {
                            id: '1',
                            model: 'gpt-3.5-turbo',
                            results: [result]
                        }
                    };
                }
            });
            const moderator = new OpenAIModerator_1.OpenAIModerator({
                apiKey: 'test',
                moderate: 'both'
            });
            const input = {
                type: 'plan',
                commands: [
                    {
                        type: 'SAY',
                        response: 'test'
                    }
                ]
            };
            const plan = await moderator.reviewPlan(new botbuilder_1.TurnContext(adapter, { text: 'test' }), state, input);
            assert_1.strict.deepEqual(plan, input);
        });
    });
});
//# sourceMappingURL=OpenAIModerator.spec.js.map