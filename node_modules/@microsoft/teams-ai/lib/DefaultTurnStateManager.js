"use strict";
/**
 * @module teams-ai
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultTurnStateManager = void 0;
const TurnState_1 = require("./TurnState");
/**
 * Default turn state manager implementation.
 * @template TConversationState Optional. Type of the conversation state object being persisted.
 * @template TUserState Optional. Type of the user state object being persisted.
 * @template TTempState Optional. Type of the temp state object being persisted.
 */
class DefaultTurnStateManager {
    /**
     * Loads all of the state scopes for the current turn.
     * @param {Storage} storage - Storage provider to load state scopes from.
     * @param {TurnContext} context - Context for the current turn of conversation with the user.
     * @returns {Promise<DefaultTurnState<TConversationState, TUserState, TTempState>>} The loaded state scopes.
     */
    async loadState(storage, context) {
        // Compute state keys
        const activity = context.activity;
        const channelId = activity?.channelId;
        const botId = activity?.recipient?.id;
        const conversationId = activity?.conversation?.id;
        const userId = activity?.from?.id;
        if (!channelId) {
            throw new Error('missing context.activity.channelId');
        }
        if (!botId) {
            throw new Error('missing context.activity.recipient.id');
        }
        if (!conversationId) {
            throw new Error('missing context.activity.conversation.id');
        }
        if (!userId) {
            throw new Error('missing context.activity.from.id');
        }
        const conversationKey = `${channelId}/${botId}/conversations/${conversationId}`;
        const userKey = `${channelId}/${botId}/users/${userId}`;
        // Read items from storage provider (if configured)
        const items = storage ? await storage.read([conversationKey, userKey]) : {};
        // Map items to state object
        const state = {
            conversation: new TurnState_1.TurnStateEntry(items[conversationKey], conversationKey),
            user: new TurnState_1.TurnStateEntry(items[userKey], userKey),
            temp: new TurnState_1.TurnStateEntry({})
        };
        return state;
    }
    /**
     * Saves all of the state scopes for the current turn.
     * @param {Storage} storage - Storage provider to save state scopes to.
     * @param {TurnContext} context - Context for the current turn of conversation with the user.
     * @param {DefaultTurnState<TConversationState, TUserState, TTempState>} state - State scopes to save.
     */
    async saveState(storage, context, state) {
        // Find changes and deletions
        let changes;
        let deletions;
        for (const key in state) {
            if (Object.prototype.hasOwnProperty.call(state, key)) {
                const entry = state[key];
                if (entry.storageKey) {
                    if (entry.isDeleted) {
                        // Add to deletion list
                        if (deletions) {
                            deletions.push(entry.storageKey);
                        }
                        else {
                            deletions = [entry.storageKey];
                        }
                    }
                    else if (entry.hasChanged) {
                        // Add to change set
                        if (!changes) {
                            changes = {};
                        }
                        changes[entry.storageKey] = entry.value;
                    }
                }
            }
        }
        // Do we have a storage provider?
        if (storage) {
            // Apply changes
            const promises = [];
            if (changes) {
                promises.push(storage.write(changes));
            }
            // Apply deletions
            if (deletions) {
                promises.push(storage.delete(deletions));
            }
            // Wait for completion
            if (promises.length > 0) {
                await Promise.all(promises);
            }
        }
    }
}
exports.DefaultTurnStateManager = DefaultTurnStateManager;
//# sourceMappingURL=DefaultTurnStateManager.js.map