"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = require("assert");
const ConversationHistory_1 = require("./ConversationHistory");
const TurnState_1 = require("./TurnState");
/* eslint-disable security/detect-object-injection */
describe('ConversationHistory', () => {
    describe('addLine()', () => {
        it('should create history if it does not exist', () => {
            const state = { conversation: new TurnState_1.TurnStateEntry() };
            ConversationHistory_1.ConversationHistory.addLine(state, 'test');
            (0, assert_1.strict)(Array.isArray(state.conversation.value[ConversationHistory_1.ConversationHistory.StatePropertyName]));
            assert_1.strict.equal(state.conversation.value[ConversationHistory_1.ConversationHistory.StatePropertyName].length, 1);
        });
        it('should prune history if too long', () => {
            const mockHistory = ['This', 'History', 'Is', 'Too', 'Long', 'To', 'Fit', 'In', 'The', 'History', 'Array'];
            const state = {
                conversation: new TurnState_1.TurnStateEntry({ [ConversationHistory_1.ConversationHistory.StatePropertyName]: mockHistory })
            };
            const mockStateAddition = 'Overflow!';
            ConversationHistory_1.ConversationHistory.addLine(state, mockStateAddition);
            assert_1.strict.equal(state.conversation.value[ConversationHistory_1.ConversationHistory.StatePropertyName].length, 10);
            assert_1.strict.equal(state.conversation.value[ConversationHistory_1.ConversationHistory.StatePropertyName][9], mockStateAddition);
        });
        it('should throw an Error if state has no "conversation" member', () => {
            const state = {};
            assert_1.strict.throws(() => ConversationHistory_1.ConversationHistory.addLine(state, 'test'));
        });
    });
    describe('appendToLastLine()', () => {
        it('should append the text to the last line', () => {
            const mockHistory = ['History'];
            const lineToBeAppended = ' is important!';
            const expectedLine = mockHistory[0] + lineToBeAppended;
            const state = {
                conversation: new TurnState_1.TurnStateEntry({ [ConversationHistory_1.ConversationHistory.StatePropertyName]: mockHistory })
            };
            ConversationHistory_1.ConversationHistory.appendToLastLine(state, lineToBeAppended);
            assert_1.strict.equal(state.conversation.value[ConversationHistory_1.ConversationHistory.StatePropertyName].length, 1);
            assert_1.strict.equal(state.conversation.value[ConversationHistory_1.ConversationHistory.StatePropertyName][0], expectedLine);
        });
    });
    describe('clear()', () => {
        it('should clear the conversation state', () => {
            const state = {
                conversation: new TurnState_1.TurnStateEntry({ [ConversationHistory_1.ConversationHistory.StatePropertyName]: ['test'] })
            };
            ConversationHistory_1.ConversationHistory.clear(state);
        });
        it('should throw an Error if state has no "conversation" member', () => {
            const state = {};
            assert_1.strict.throws(() => ConversationHistory_1.ConversationHistory.clear(state));
        });
    });
    describe('hasMoreLines()', () => {
        it('should return true when there is history, otherwise false', () => {
            const state = {
                conversation: new TurnState_1.TurnStateEntry({ [ConversationHistory_1.ConversationHistory.StatePropertyName]: ['1'] })
            };
            (0, assert_1.strict)(ConversationHistory_1.ConversationHistory.hasMoreLines(state));
            const emptyState = {
                conversation: new TurnState_1.TurnStateEntry({ [ConversationHistory_1.ConversationHistory.StatePropertyName]: [] })
            };
            (0, assert_1.strict)(!ConversationHistory_1.ConversationHistory.hasMoreLines(emptyState));
        });
        it('should throw an Error if state has no "conversation" member', () => {
            const state = {};
            assert_1.strict.throws(() => ConversationHistory_1.ConversationHistory.hasMoreLines(state));
        });
    });
    describe('getLastLine()', () => {
        it('should return the last line in the history', () => {
            const expectedLastLine = 'test';
            const state = {
                conversation: new TurnState_1.TurnStateEntry({ [ConversationHistory_1.ConversationHistory.StatePropertyName]: [expectedLastLine] })
            };
            const lastLine = ConversationHistory_1.ConversationHistory.getLastLine(state);
            assert_1.strict.equal(lastLine, expectedLastLine);
        });
        it('should return empty string if history is not an array', () => {
            const state = {
                conversation: new TurnState_1.TurnStateEntry({ [ConversationHistory_1.ConversationHistory.StatePropertyName]: null })
            };
            const lastLine = ConversationHistory_1.ConversationHistory.getLastLine(state);
            assert_1.strict.equal(lastLine, '');
        });
        it('should throw an Error if state has no "conversation" member', () => {
            const state = {};
            assert_1.strict.throws(() => ConversationHistory_1.ConversationHistory.getLastLine(state));
        });
    });
    describe('getLastSay()', () => {
        it('should return the last SAY response', async () => {
            const expectedResponse = 'Response';
            const state = {
                conversation: new TurnState_1.TurnStateEntry({
                    [ConversationHistory_1.ConversationHistory.StatePropertyName]: [`Assistant: SAY ${expectedResponse}`]
                })
            };
            const lastSay = ConversationHistory_1.ConversationHistory.getLastSay(state);
            assert_1.strict.equal(lastSay, expectedResponse);
        });
        it('should return whole last line if no SAY is found', async () => {
            const expectedResponse = 'Response';
            const state = {
                conversation: new TurnState_1.TurnStateEntry({
                    [ConversationHistory_1.ConversationHistory.StatePropertyName]: [expectedResponse]
                })
            };
            const lastSay = ConversationHistory_1.ConversationHistory.getLastSay(state);
            assert_1.strict.equal(lastSay, expectedResponse);
        });
    });
    describe('removeLastLine()', () => {
        it('should return last line and update history', () => {
            const expectedLastLine = 'Line To Be Removed';
            const state = {
                conversation: new TurnState_1.TurnStateEntry({ [ConversationHistory_1.ConversationHistory.StatePropertyName]: ['1', expectedLastLine] })
            };
            const removedLastLine = ConversationHistory_1.ConversationHistory.removeLastLine(state);
            assert_1.strict.equal(state.conversation.value[ConversationHistory_1.ConversationHistory.StatePropertyName].length, 1);
            assert_1.strict.equal(removedLastLine, expectedLastLine);
        });
        it('should create history if it does not exist and return undefined', () => {
            const state = { conversation: new TurnState_1.TurnStateEntry() };
            const undefinedString = ConversationHistory_1.ConversationHistory.removeLastLine(state);
            assert_1.strict.equal(state.conversation.value[ConversationHistory_1.ConversationHistory.StatePropertyName].length, 0);
            (0, assert_1.strict)(undefinedString === undefined);
        });
        it('should throw an Error if state has no "conversation" member', () => {
            const state = {};
            assert_1.strict.throws(() => ConversationHistory_1.ConversationHistory.removeLastLine(state));
        });
    });
    describe('replaceLastLine()', () => {
        it('should replace the last line of history', () => {
            const expectedLastLine = 'expected';
            const state = {
                conversation: new TurnState_1.TurnStateEntry({ [ConversationHistory_1.ConversationHistory.StatePropertyName]: ['ToBeReplaced'] })
            };
            ConversationHistory_1.ConversationHistory.replaceLastLine(state, expectedLastLine);
            const lastLine = ConversationHistory_1.ConversationHistory.getLastLine(state);
            assert_1.strict.equal(state.conversation.value[ConversationHistory_1.ConversationHistory.StatePropertyName].length, 1);
            assert_1.strict.equal(lastLine, expectedLastLine);
        });
        it('should set the last line if no history exists', () => {
            const expectedLastLine = 'test';
            const state = {
                conversation: new TurnState_1.TurnStateEntry({ [ConversationHistory_1.ConversationHistory.StatePropertyName]: null })
            };
            ConversationHistory_1.ConversationHistory.replaceLastLine(state, expectedLastLine);
            const lastLine = ConversationHistory_1.ConversationHistory.getLastLine(state);
            assert_1.strict.equal(state.conversation.value[ConversationHistory_1.ConversationHistory.StatePropertyName].length, 1);
            assert_1.strict.equal(lastLine, expectedLastLine);
        });
        it('should throw an Error if state has no "conversation" member', () => {
            const state = {};
            assert_1.strict.throws(() => ConversationHistory_1.ConversationHistory.replaceLastLine(state, 'line'));
        });
    });
    describe('replaceLastSay()', () => {
        it('should replace the last SAY with a new response', () => {
            const expectedSay = 'New Expected Response';
            const state = {
                conversation: new TurnState_1.TurnStateEntry({
                    [ConversationHistory_1.ConversationHistory.StatePropertyName]: ['Assistant: SAY ToBeReplaced']
                })
            };
            ConversationHistory_1.ConversationHistory.replaceLastSay(state, expectedSay);
            const lastSay = ConversationHistory_1.ConversationHistory.getLastSay(state);
            assert_1.strict.equal(lastSay, expectedSay);
        });
        it('should set a new SAY if no history exists', () => {
            const expectedSay = 'New Expected Response';
            const state = {
                conversation: new TurnState_1.TurnStateEntry({ [ConversationHistory_1.ConversationHistory.StatePropertyName]: null })
            };
            ConversationHistory_1.ConversationHistory.replaceLastSay(state, expectedSay);
            const lastSay = ConversationHistory_1.ConversationHistory.getLastSay(state);
            assert_1.strict.equal(lastSay, expectedSay);
        });
        it('should append SAY after any DO', () => {
            const originalLastLine = 'Assistant: DO WishForAResponse';
            const expectedSay = 'New Expected Response';
            const expectedLastLine = `${originalLastLine} THEN SAY ${expectedSay}`;
            const state = {
                conversation: new TurnState_1.TurnStateEntry({
                    [ConversationHistory_1.ConversationHistory.StatePropertyName]: [originalLastLine]
                })
            };
            ConversationHistory_1.ConversationHistory.replaceLastSay(state, expectedSay);
            const lastSay = ConversationHistory_1.ConversationHistory.getLastSay(state);
            assert_1.strict.equal(lastSay, expectedSay);
            const lastLine = ConversationHistory_1.ConversationHistory.getLastLine(state);
            assert_1.strict.equal(lastLine, expectedLastLine);
        });
        // Just a note, since this behavior will change in the short-term.
        // This behavior doesn't follow the same behavior as when a SAY or DO is already found in the last line.
        // We need to decide if the newResponse should always have `SAY ` prefixed or not.
        it.skip('should replace entire last line if no SAY or DO found', () => {
            const replacingResponse = 'New Expected Response';
            const expectedLastLine = `Assistant: SAY ${replacingResponse}`;
            const state = {
                conversation: new TurnState_1.TurnStateEntry({
                    [ConversationHistory_1.ConversationHistory.StatePropertyName]: ['LineToBeReplaced']
                })
            };
            ConversationHistory_1.ConversationHistory.replaceLastSay(state, replacingResponse);
            const lastSay = ConversationHistory_1.ConversationHistory.getLastSay(state);
            assert_1.strict.equal(lastSay, replacingResponse);
            const lastLine = ConversationHistory_1.ConversationHistory.getLastLine(state);
            assert_1.strict.equal(lastLine, expectedLastLine);
        });
        it('should throw an Error if state has no "conversation" member', () => {
            const state = {};
            assert_1.strict.throws(() => ConversationHistory_1.ConversationHistory.replaceLastSay(state, 'newResponse'));
        });
    });
    describe('toString()', () => {
        it('should return the most recent lines of history as a string', () => {
            const mockHistory = ['History', ' is important!'];
            const expectedLine = mockHistory[0] + '\n' + mockHistory[1];
            const state = {
                conversation: new TurnState_1.TurnStateEntry({ [ConversationHistory_1.ConversationHistory.StatePropertyName]: mockHistory })
            };
            const stringHistory = ConversationHistory_1.ConversationHistory.toString(state);
            assert_1.strict.equal(stringHistory, expectedLine);
        });
        it('should respect the maxTokens and lineSeparator parameters', () => {
            const mockHistory = ['Older Skipped Tokens', 'Skipped Tokens', 'History Rules!'];
            const lineSeparator = '*';
            const expectedLine = mockHistory[2] + lineSeparator;
            const state = {
                conversation: new TurnState_1.TurnStateEntry({ [ConversationHistory_1.ConversationHistory.StatePropertyName]: mockHistory })
            };
            const stringHistory = ConversationHistory_1.ConversationHistory.toString(state, 4, lineSeparator);
            assert_1.strict.equal(stringHistory, expectedLine);
        });
        it('should throw an Error if state has no "conversation" member', () => {
            const state = {};
            assert_1.strict.throws(() => ConversationHistory_1.ConversationHistory.toString(state));
        });
    });
    describe('toArray()', () => {
        it('should return the most recent lines of history as an array', () => {
            const mockHistory = ['History', ' is important!'];
            const state = {
                conversation: new TurnState_1.TurnStateEntry({ [ConversationHistory_1.ConversationHistory.StatePropertyName]: mockHistory })
            };
            const stateHistory = ConversationHistory_1.ConversationHistory.toArray(state);
            assert_1.strict.equal(stateHistory.length, 2);
            assert_1.strict.equal(stateHistory[0], mockHistory[0]);
            assert_1.strict.equal(stateHistory[1], mockHistory[1]);
        });
        it('should respect the maxTokens parameter', () => {
            const mockHistory = ['Skipped tokens', 'History'];
            const state = {
                conversation: new TurnState_1.TurnStateEntry({ [ConversationHistory_1.ConversationHistory.StatePropertyName]: mockHistory })
            };
            const stateHistory = ConversationHistory_1.ConversationHistory.toArray(state, 1);
            assert_1.strict.equal(stateHistory.length, 1);
            assert_1.strict.equal(stateHistory[0], mockHistory[1]);
        });
        it('should throw an Error if state has no "conversation" member', () => {
            const state = {};
            assert_1.strict.throws(() => ConversationHistory_1.ConversationHistory.toArray(state));
        });
    });
});
//# sourceMappingURL=ConversationHistory.spec.js.map