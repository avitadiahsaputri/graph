"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = require("assert");
const botbuilder_1 = require("botbuilder");
const Application_1 = require("./Application");
const TestPlanner_1 = require("./TestPlanner");
const TestPromptManager_1 = require("./TestPromptManager");
const DefaultTurnStateManager_1 = require("./DefaultTurnStateManager");
const TestUtilities_1 = require("./TestUtilities");
describe('Application', () => {
    const adapter = new botbuilder_1.TestAdapter();
    const adaptiveCards = { actionSubmitFilter: 'cardFilter' };
    const ai = {
        planner: new TestPlanner_1.TestPlanner(),
        promptManager: new TestPromptManager_1.TestPromptManager()
    };
    const botAppId = 'testBot';
    const longRunningMessages = true;
    const removeRecipientMention = false;
    const startTypingTimer = false;
    const storage = new botbuilder_1.MemoryStorage();
    const taskModules = { taskDataFilter: 'taskFilter' };
    const turnStateManager = new DefaultTurnStateManager_1.DefaultTurnStateManager();
    describe('constructor()', () => {
        it('should create an Application with default options', () => {
            const app = new Application_1.Application();
            assert_1.strict.notEqual(app.options, undefined);
            assert_1.strict.equal(app.options.adapter, undefined);
            assert_1.strict.equal(app.options.adaptiveCards, undefined);
            assert_1.strict.equal(app.options.ai, undefined);
            assert_1.strict.equal(app.options.botAppId, undefined);
            assert_1.strict.equal(app.options.longRunningMessages, false);
            assert_1.strict.equal(app.options.removeRecipientMention, true);
            assert_1.strict.equal(app.options.startTypingTimer, true);
            assert_1.strict.equal(app.options.storage, undefined);
            assert_1.strict.equal(app.options.taskModules, undefined);
            assert_1.strict.notEqual(app.options.turnStateManager, undefined);
        });
        it('should create an Application with custom options', () => {
            const app = new Application_1.Application({
                adapter,
                adaptiveCards,
                ai,
                botAppId,
                longRunningMessages,
                removeRecipientMention,
                startTypingTimer,
                storage,
                taskModules,
                turnStateManager
            });
            assert_1.strict.notEqual(app.options, undefined);
            assert_1.strict.equal(app.options.adapter, adapter);
            assert_1.strict.deepEqual(app.options.adaptiveCards, adaptiveCards);
            assert_1.strict.deepEqual(app.options.ai, ai);
            assert_1.strict.equal(app.options.botAppId, botAppId);
            assert_1.strict.equal(app.options.longRunningMessages, longRunningMessages);
            assert_1.strict.equal(app.options.removeRecipientMention, removeRecipientMention);
            assert_1.strict.equal(app.options.startTypingTimer, startTypingTimer);
            assert_1.strict.equal(app.options.storage, storage);
            assert_1.strict.deepEqual(app.options.taskModules, taskModules);
            assert_1.strict.equal(app.options.turnStateManager, turnStateManager);
        });
    });
    describe('applicationBuilder', () => {
        it('should create an Application with default options', () => {
            const app = new Application_1.ApplicationBuilder().build();
            assert_1.strict.notEqual(app.options, undefined);
            assert_1.strict.equal(app.options.adapter, undefined);
            assert_1.strict.equal(app.options.botAppId, undefined);
            assert_1.strict.equal(app.options.storage, undefined);
            assert_1.strict.equal(app.options.ai, undefined);
            assert_1.strict.notEqual(app.options.turnStateManager, undefined);
            assert_1.strict.equal(app.options.adaptiveCards, undefined);
            assert_1.strict.equal(app.options.taskModules, undefined);
            assert_1.strict.equal(app.options.removeRecipientMention, true);
            assert_1.strict.equal(app.options.startTypingTimer, true);
            assert_1.strict.equal(app.options.longRunningMessages, false);
        });
        it('should create an Application with custom options', () => {
            const app = new Application_1.ApplicationBuilder()
                .setRemoveRecipientMention(removeRecipientMention)
                .withStorage(storage)
                .withAIOptions(ai)
                .withLongRunningMessages(adapter, botAppId)
                .withTurnStateManager(turnStateManager)
                .withAdaptiveCardOptions(adaptiveCards)
                .withTaskModuleOptions(taskModules)
                .setStartTypingTimer(startTypingTimer)
                .build();
            assert_1.strict.notEqual(app.options, undefined);
            assert_1.strict.equal(app.options.adapter, adapter);
            assert_1.strict.equal(app.options.botAppId, botAppId);
            assert_1.strict.equal(app.options.storage, storage);
            assert_1.strict.equal(app.options.ai, ai);
            assert_1.strict.equal(app.options.turnStateManager, turnStateManager);
            assert_1.strict.equal(app.options.adaptiveCards, adaptiveCards);
            assert_1.strict.equal(app.options.taskModules, taskModules);
            assert_1.strict.equal(app.options.removeRecipientMention, removeRecipientMention);
            assert_1.strict.equal(app.options.startTypingTimer, startTypingTimer);
            assert_1.strict.equal(app.options.longRunningMessages, longRunningMessages);
        });
        it('should throw an exception if botId is an empty string for longRunningMessages', () => {
            assert_1.strict.throws(() => {
                new Application_1.ApplicationBuilder().withLongRunningMessages(adapter, '').build();
            });
        });
    });
    describe('adaptiveCards', () => {
        it('should return the adaptiveCards property', () => {
            const app = new Application_1.Application();
            assert_1.strict.notEqual(app.adaptiveCards, undefined);
        });
    });
    describe('ai', () => {
        it('should throw exception if ai not configured', () => {
            const app = new Application_1.Application();
            assert_1.strict.throws(() => app.ai);
        });
        it('should return the ai property', () => {
            const app = new Application_1.Application({
                ai
            });
            assert_1.strict.notEqual(app.ai, undefined);
        });
    });
    describe('messageExtensions', () => {
        it('should return the messageExtensions property', () => {
            const app = new Application_1.Application();
            assert_1.strict.notEqual(app.messageExtensions, undefined);
        });
    });
    describe('taskModules', () => {
        it('should return the taskModules property', () => {
            const app = new Application_1.Application();
            assert_1.strict.notEqual(app.taskModules, undefined);
        });
    });
    describe('activity', () => {
        it('should route to an activity handler', async () => {
            let called = false;
            const app = new Application_1.Application();
            app.activity(botbuilder_1.ActivityTypes.Message, async (context, state) => {
                assert_1.strict.notEqual(context, undefined);
                assert_1.strict.notEqual(state, undefined);
                called = true;
            });
            await adapter.sendTextToBot('test', async (context) => {
                const handled = await app.run(context);
                assert_1.strict.equal(called, true);
                assert_1.strict.equal(handled, true);
            });
        });
        it("should not route activity if there's no handler", async () => {
            const app = new Application_1.Application();
            await adapter.sendTextToBot('test', async (context) => {
                const handled = await app.run(context);
                assert_1.strict.equal(handled, false);
            });
        });
        it('should route to first registered activity handler', async () => {
            let called = false;
            const app = new Application_1.Application();
            app.activity(botbuilder_1.ActivityTypes.Message, async (context, state) => {
                called = true;
            });
            app.activity(botbuilder_1.ActivityTypes.Message, async (context, state) => {
                assert_1.strict.fail('should not be called');
            });
            await adapter.sendTextToBot('test', async (context) => {
                const handled = await app.run(context);
                assert_1.strict.equal(called, true);
                assert_1.strict.equal(handled, true);
            });
        });
    });
    describe('conversationUpdate', () => {
        // Optional pre-configured mock Application using Test Adapter. If other mocks are needed, feel free to ignore mockApp and create your own.
        let mockApp;
        beforeEach(() => {
            mockApp = new Application_1.Application({ adapter });
        });
        it('should route to an instantiated conversationUpdate handler when channelId is Teams', async () => {
            let handlerCalled = false;
            mockApp.conversationUpdate('membersAdded', async (context, _state) => {
                handlerCalled = true;
                assert_1.strict.equal(context.activity.membersAdded && context.activity.membersAdded.length, 2);
            });
            const activity = (0, TestUtilities_1.createTestConversationUpdate)();
            activity.channelId = 'msteams';
            activity.membersAdded = [
                { id: '123', name: 'Member One' },
                { id: '42', name: "Don't Panic" }
            ];
            await adapter.processActivity(activity, async (context) => {
                await mockApp.run(context);
                assert_1.strict.equal(handlerCalled, true);
            });
        });
        it('should route to an instantiated conversationUpdate handler when channelId is not defined', async () => {
            let handlerCalled = false;
            mockApp.conversationUpdate('membersAdded', async (context, _state) => {
                handlerCalled = true;
                assert_1.strict.equal(context.activity.membersAdded && context.activity.membersAdded.length, 2);
            });
            const activity = (0, TestUtilities_1.createTestConversationUpdate)();
            activity.membersAdded = [
                { id: '123', name: 'Member One' },
                { id: '42', name: "Don't Panic" }
            ];
            await adapter.processActivity(activity, async (context) => {
                await mockApp.run(context);
                assert_1.strict.equal(handlerCalled, true);
            });
        });
        const testData = [
            {
                event: 'channelCreated',
                channelData: {
                    channel: { id: 'mockChannelId' },
                    team: { id: 'mockTeamId' },
                    eventType: 'channelCreated'
                }
            },
            {
                event: 'channelDeleted',
                channelData: {
                    channel: { id: 'mockChannelId' },
                    team: { id: 'mockTeamId' },
                    eventType: 'channelDeleted'
                }
            },
            {
                event: 'teamRenamed',
                channelData: { team: { id: 'mockTeamId' }, eventType: 'teamRenamed' }
            },
            {
                event: 'teamDeleted',
                channelData: { team: { id: 'mockTeamId' }, eventType: 'teamDeleted' }
            }
        ];
        for (const { event, channelData } of testData) {
            it(`should route to correct handler for '${event}'`, async () => {
                let handlerCalled = false;
                mockApp.conversationUpdate(event, async (context, _state) => {
                    handlerCalled = true;
                    assert_1.strict.equal(context.activity.channelData.eventType, event);
                    assert_1.strict.deepEqual(context.activity.channelData, channelData);
                });
                const activity = (0, TestUtilities_1.createTestConversationUpdate)(channelData);
                activity.channelId = 'msteams';
                await adapter.processActivity(activity, async (context) => {
                    await mockApp.run(context);
                    assert_1.strict.equal(handlerCalled, true);
                });
            });
        }
        it('should route to channel* events for correct eventType and when channel and team exist', async () => {
            let handlerCalled = false;
            const team = { id: 'mockTeamId' };
            const channel = { id: 'mockChannelId' };
            const activity = (0, TestUtilities_1.createTestConversationUpdate)({ channel, eventType: 'channelCreated', team });
            activity.channelId = 'msteams';
            mockApp.conversationUpdate('channelCreated', async (context, _state) => {
                handlerCalled = true;
                assert_1.strict.equal(typeof context.activity.channelData, 'object');
                assert_1.strict.equal(context.activity.channelData.eventType, 'channelCreated');
                assert_1.strict.deepEqual(context.activity.channelData.channel, channel);
                assert_1.strict.deepEqual(context.activity.channelData.team, team);
            });
            await adapter.processActivity(activity, async (context) => {
                await mockApp.run(context);
                assert_1.strict.equal(handlerCalled, true);
            });
        });
        it('should throw an error if handler is not a function', () => {
            assert_1.strict.throws(() => mockApp.conversationUpdate('membersRemoved', {}), new Error(`ConversationUpdate 'handler' for membersRemoved is object. Type of 'handler' must be a function.`));
        });
    });
});
//# sourceMappingURL=Application.spec.js.map