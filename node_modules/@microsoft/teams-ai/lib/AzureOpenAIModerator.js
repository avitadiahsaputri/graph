"use strict";
// TODO: Remove these lines once the linting issues are resolved:
/* eslint-disable jsdoc/require-returns */
/* eslint-disable security/detect-object-injection */
/**
 * @module teams-ai
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AzureOpenAIModerator = void 0;
const OpenAIClients_1 = require("./OpenAIClients");
const AI_1 = require("./AI");
const OpenAIModerator_1 = require("./OpenAIModerator");
const axios_1 = require("axios");
const defaultHarmCategories = ['Hate', 'Sexual', 'SelfHarm', 'Violence'];
/**
 * An Azure OpenAI moderator that uses OpenAI's moderation API to review prompts and plans for safety.
 * @summary
 * This moderation can be configured to review the input from the user, output from the model, or both.
 * @template TState Optional. Type of the applications turn state.
 */
class AzureOpenAIModerator extends OpenAIModerator_1.OpenAIModerator {
    _contentSafetyOptions;
    _azureContentSafetyClient;
    _azureContentSafetyCategories = {};
    /**
     * Creates a new instance of the OpenAI based moderator.
     * @param {AzureOpenAIModeratorOptions} options Configuration options for the moderator.
     */
    constructor(options) {
        // Create the moderator options
        const moderatorOptions = {
            apiKey: options.apiKey,
            moderate: options.moderate ?? 'both',
            endpoint: options.endpoint,
            apiVersion: options.apiVersion
        };
        super(moderatorOptions);
        // Create the Azure OpenAI Content Safety client
        this._azureContentSafetyClient = this.createClient(moderatorOptions);
        // Construct the content safety categories
        let categories = [];
        if (options.categories) {
            options.categories.forEach((category) => {
                categories.push(category.category);
                this._azureContentSafetyCategories[category.category] = category;
            });
        }
        else {
            categories = Object.assign([], defaultHarmCategories);
            this._azureContentSafetyCategories.Hate = {
                category: 'Hate',
                severity: 6
            };
            this._azureContentSafetyCategories.Sexual = {
                category: 'Sexual',
                severity: 6
            };
            this._azureContentSafetyCategories.SelfHarm = {
                category: 'SelfHarm',
                severity: 6
            };
            this._azureContentSafetyCategories.Violence = {
                category: 'Violence',
                severity: 6
            };
        }
        // Create the content safety request
        this._contentSafetyOptions = {
            categories: categories ?? defaultHarmCategories,
            blocklistNames: options.blocklistNames ?? [],
            breakByBlocklists: options.breakByBlocklists ?? false
        };
    }
    /**
     * Creates a new instance of the Azure OpenAI client.
     * @protected
     * @param {OpenAIModeratorOptions} options The options for the moderator.
     * @returns {AzureOpenAIClient} The Azure OpenAI client.
     */
    createClient(options) {
        return new OpenAIClients_1.AzureOpenAIClient({
            apiKey: options.apiKey,
            endpoint: options.endpoint,
            apiVersion: options.apiVersion ?? '2023-04-30-preview',
            headerKey: 'Ocp-Apim-Subscription-Key'
        });
    }
    /**
     * @protected
     * @param {string} input The input to moderate.
     * @returns {Promise<CreateModerationResponseResultsInner | undefined>} The moderation results.
     * This method is called by the moderator to moderate the input.
     * @template TState Optional. Type of the applications turn state.
     */
    async createModeration(input) {
        const response = (await this._azureContentSafetyClient.createModeration({
            text: input,
            ...this._contentSafetyOptions
        }));
        const data = response.data;
        if (!data) {
            throw new axios_1.AxiosError(response.statusText, response.status.toString());
        }
        // Check if the input is safe for each category
        const hateResult = data.hateResult?.severity > 0 &&
            data.hateResult.severity <= this._azureContentSafetyCategories.Hate.severity;
        const selfHarmResult = data.selfHarmResult?.severity > 0 &&
            data.selfHarmResult.severity <= this._azureContentSafetyCategories.SelfHarm.severity;
        const sexualResult = data.sexualResult?.severity > 0 &&
            data.sexualResult.severity <= this._azureContentSafetyCategories.Sexual.severity;
        const violenceResult = data.violenceResult?.severity > 0 &&
            data.violenceResult.severity <= this._azureContentSafetyCategories.Violence.severity;
        // Create the moderation results
        const result = {
            flagged: hateResult || selfHarmResult || sexualResult || violenceResult,
            categories: {
                hate: hateResult,
                'hate/threatening': hateResult,
                'self-harm': selfHarmResult,
                sexual: sexualResult,
                'sexual/minors': sexualResult,
                violence: violenceResult,
                'violence/graphic': violenceResult
            },
            category_scores: {
                // Normalize the scores to be between 0 and 1
                hate: (data.hateResult?.severity ?? 0) / OpenAIClients_1.ModerationSeverity.High,
                'hate/threatening': (data.hateResult?.severity ?? 0) / OpenAIClients_1.ModerationSeverity.High,
                'self-harm': (data.selfHarmResult?.severity ?? 0) / OpenAIClients_1.ModerationSeverity.High,
                sexual: (data.sexualResult?.severity ?? 0) / OpenAIClients_1.ModerationSeverity.High,
                'sexual/minors': (data.sexualResult?.severity ?? 0) / OpenAIClients_1.ModerationSeverity.High,
                violence: (data.violenceResult?.severity ?? 0) / OpenAIClients_1.ModerationSeverity.High,
                'violence/graphic': (data.violenceResult?.severity ?? 0) / OpenAIClients_1.ModerationSeverity.High
            }
        };
        return result;
    }
    /**
     * Reviews an incoming prompt for safety violations.
     * @param {TurnContext} context Context for the current turn of conversation.
     * @param {TState} state Application state for the current turn of conversation.
     * @param {PromptTemplate} prompt Generated prompt to be reviewed.
     * @param {ConfiguredAIOptions<TState>} options Current options for the AI system.
     * @returns {Promise<Plan | undefined>} An undefined value to approve the prompt or a new plan to redirect to if not approved.
     */
    async reviewPrompt(context, state, prompt, options) {
        switch (this.options.moderate) {
            case 'input':
            case 'both': {
                const input = state?.temp?.value.input ?? context.activity.text;
                try {
                    const result = await this.createModeration(input);
                    if (result.flagged) {
                        // Input flagged
                        return {
                            type: 'plan',
                            commands: [
                                {
                                    type: 'DO',
                                    action: AI_1.AI.FlaggedInputActionName,
                                    entities: result
                                }
                            ]
                        };
                    }
                }
                catch (err) {
                    if (err instanceof axios_1.AxiosError) {
                        return {
                            type: 'plan',
                            commands: [
                                {
                                    type: 'DO',
                                    action: AI_1.AI.HttpErrorActionName,
                                    entities: {
                                        code: err.code,
                                        message: err.message
                                    }
                                }
                            ]
                        };
                    }
                    throw err;
                }
                break;
            }
        }
        return undefined;
    }
    /**
     * Reviews the SAY commands generated by the planner for safety violations.
     * @param {TurnContext} context Context for the current turn of conversation.
     * @param {TState} state Application state for the current turn of conversation.
     * @param {Plan} plan Plan generated by the planner.
     * @returns {Promise<Plan>} The plan to execute. Either the current plan passed in for review or a new plan.
     */
    async reviewPlan(context, state, plan) {
        switch (this.options.moderate) {
            case 'output':
            case 'both':
                for (let i = 0; i < plan.commands.length; i++) {
                    const cmd = plan.commands[i];
                    if (cmd.type == 'SAY') {
                        const predictedSayCommand = cmd;
                        const output = predictedSayCommand.response;
                        try {
                            const result = await this.createModeration(output);
                            if (result.flagged) {
                                // Output flagged
                                return {
                                    type: 'plan',
                                    commands: [
                                        {
                                            type: 'DO',
                                            action: AI_1.AI.FlaggedOutputActionName,
                                            entities: result
                                        }
                                    ]
                                };
                            }
                        }
                        catch (err) {
                            if (err instanceof axios_1.AxiosError) {
                                return {
                                    type: 'plan',
                                    commands: [
                                        {
                                            type: 'DO',
                                            action: AI_1.AI.HttpErrorActionName,
                                            entities: {
                                                code: err.code,
                                                message: err.message
                                            }
                                        }
                                    ]
                                };
                            }
                            throw err;
                        }
                    }
                }
                break;
        }
        return plan;
    }
}
exports.AzureOpenAIModerator = AzureOpenAIModerator;
//# sourceMappingURL=AzureOpenAIModerator.js.map